const {ClientError} = require('./client_error');
const {EllipticSigner, WebCryptoSigner} = require('./signer');
const {TextEncoder} = require('./request/builder');
const {StatusCode} = require('./status_code');
const {
  CertificateRegistrationRequestBuilder,
  FunctionRegistrationRequestBuilder,
  ContractRegistrationRequestBuilder,
  ContractsListingRequestBuilder,
  LedgerValidationRequestBuilder,
  ContractExecutionRequestBuilder,
} = require('./request/builder');

class GrpcMessageGetter {
  /**
   * @param {Object} properties
   * @param {Object} protobuf
   */
  constructor(properties, protobuf) {
    /** @const */
    this.privateKeyPem = this._getRequiredProperty(properties,
        'scalar.dl.client.private_key_pem');
    /** @const */
    this.certPem = this._getRequiredProperty(properties,
        'scalar.dl.client.cert_pem');
    /** @const */
    this.certHolderId = this._getRequiredProperty(properties,
        'scalar.dl.client.cert_holder_id');
    /** @const */
    this.certVersion = properties['scalar.dl.client.cert_version'];

    /** @const */
    if (this._isNodeJsRuntime()) {
      this.signer = new EllipticSigner(this.privateKeyPem);
    } else {
      this.signer = new WebCryptoSigner(this.privateKeyPem);
    }

    /**
     * The protobuf message object generated by gRPC library
     * @constant
     */
    this.protobuf = protobuf;
  }

  /**
   * @param {Object} properties JSON Object used for setting client properties
   * @param {string} name the name of the property to get
   * @return {Object} The client property specified in the @name parameter
   */
  _getRequiredProperty(properties, name) {
    const value = properties[name];
    if (!value) {
      throw new ClientError(
          StatusCode.CLIENT_IO_ERROR,
          `property '${name}' is required`,
      );
    }
    return value;
  }

  /**
   * @return {Uint8Array}
   */
  async getCertificateRegistrationRequest() {
    const builder = new CertificateRegistrationRequestBuilder(
        new this.protobuf.CertificateRegistrationRequest(),
    ).withCertHolderId(this.certHolderId)
    .withCertVersion(this.certVersion)
    .withCertPem(this.certPem);

    return await builder.getByteArray();
  }

  /**
   * @param {string} functionId of the function
   * @param {string} functionBinaryName of the function
   * @param {Uint8Array} functionBytes of the function
   * @return {Uint8Array}
   */
  async getFunctionRegistrationRequest(functionId, functionBinaryName,
      functionBytes) {
    if (!(functionBytes instanceof Uint8Array)) {
      throw new ClientError(
          StatusCode.CLIENT_IO_ERROR,
          'parameter functionBytes is not a \'Uint8Array\'',
      );
    }
    const builder = new FunctionRegistrationRequestBuilder(
        new this.protobuf.FunctionRegistrationRequest(),
    ).withFunctionId(functionId)
    .withFunctionBinaryName(functionBinaryName)
    .withFunctionByteCode(functionBytes);

    return await builder.getByteArray();
  }

  /**
   * @param {string} contractId of the function
   * @param {string} contractBinaryName of the function
   * @param {Uint8Array} contractBytesCode of the function
   * @param {object} properties of the function
   * @return {Uint8Array}
   */
  async getContractRegistrationRequest(contractId, contractBinaryName,
      contractBytesCode, properties) {
    if (!(contractBytesCode instanceof Uint8Array)) {
      throw new ClientError(
          StatusCode.CLIENT_IO_ERROR,
          'parameter contractBytes is not a \'Uint8Array\'',
      );
    }

    const propertiesJson = JSON.stringify(properties);
    const builder = new ContractRegistrationRequestBuilder(
        new this.protobuf.ContractRegistrationRequest(),
        this.signer,
    ).withContractId(contractId)
    .withContractBinaryName(contractBinaryName)
    .withContractByteCode(contractBytesCode)
    .withContractProperties(propertiesJson)
    .withCertHolderId(this.certHolderId)
    .withCertVersion(this.certVersion);

    return await builder.getByteArray();
  }

  /**
   * @param {string} contractId of the function
   * @return {Uint8Array}
   */
  async getContractListingRequest(contractId) {
    const builder = new ContractsListingRequestBuilder(
        new this.protobuf.ContractsListingRequest(),
        this.signer,
    ).withCertHolderId(this.certHolderId)
    .withCertVersion(this.certVersion)
    .withContractId(contractId);

    return await builder.getByteArray();
  }

  /**
   * @param {string} contractId
   * @param {Object} contractArgument
   * @param {Object} [functionArgument=undefined]
   * @return {Uint8Array}
   */
  async getContractExecutionRequest(contractId, contractArgument,
      functionArgument) {
    const argumentJson = JSON.stringify(contractArgument);
    const functionArgumentJson = JSON.stringify(functionArgument);
    const builder = new ContractExecutionRequestBuilder(
        new this.protobuf.ContractExecutionRequest(),
        this.signer,
    ).withContractId(contractId)
    .withContractArgument(argumentJson)
    .withFunctionArgument(functionArgumentJson)
    .withCertHolderId(this.certHolderId)
    .withCertVersion(this.certVersion);

    return await builder.getByteArray();
  }

  /**
   * @param {string} [assetId]
   * @return {Uint8Array}
   */
  async getLedgerValidationRequest(assetId) {
    const builder = new LedgerValidationRequestBuilder(
        new this.protobuf.LedgerValidationRequest(),
        this.signer,
    ).withAssetId(assetId)
    .withCertHolderId(this.certHolderId)
    .withCertVersion(this.certVersion);

    return await builder.getByteArray();
  }

  /**
   *
   * @return {boolean} true if the runtime is Node.js
   * @private
   */
  _isNodeJsRuntime() {
    return typeof window === 'undefined';
  }
}

module.exports = {
  GrpcMessageGetter,
};
